var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import PropTypes from 'prop-types';
import { css } from 'ui-box';
import { Pane } from '../../layers';
import { Paragraph, Heading } from '../../typography';
import { Overlay } from '../../overlay';
import { Button, IconButton } from '../../buttons';

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)'
};

var ANIMATION_DURATION = 200;

var openAnimation = css.keyframes('openAnimation', {
  from: {
    transform: 'scale(0.8)',
    opacity: 0
  },
  to: {
    transform: 'scale(1)',
    opacity: 1
  }
});

var closeAnimation = css.keyframes('closeAnimation', {
  from: {
    transform: 'scale(1)',
    opacity: 1
  },
  to: {
    transform: 'scale(0.8)',
    opacity: 0
  }
});

var animationStyles = {
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: openAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.deceleration + ' both'
  },
  '&[data-state="exiting"]': {
    animation: closeAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.acceleration + ' both'
  }
};

var Dialog = function (_React$Component) {
  _inherits(Dialog, _React$Component);

  function Dialog() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Dialog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Dialog.__proto__ || Object.getPrototypeOf(Dialog)).call.apply(_ref, [this].concat(args))), _this), _this.renderChildren = function (close) {
      var children = _this.props.children;


      if (typeof children === 'function') {
        return children({ close: close });
      } else if (typeof children === 'string') {
        return React.createElement(
          Paragraph,
          null,
          children
        );
      }
      return children;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Dialog, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          title = _props.title,
          width = _props.width,
          type = _props.type,
          isShown = _props.isShown,
          topOffset = _props.topOffset,
          hasHeader = _props.hasHeader,
          hasFooter = _props.hasFooter,
          hasCancel = _props.hasCancel,
          onCloseComplete = _props.onCloseComplete,
          onOpenComplete = _props.onOpenComplete,
          onConfirm = _props.onConfirm,
          confirmLabel = _props.confirmLabel,
          isConfirmLoading = _props.isConfirmLoading,
          isConfirmDisabled = _props.isConfirmDisabled,
          cancelLabel = _props.cancelLabel,
          containerProps = _props.containerProps,
          minHeightContent = _props.minHeightContent;


      var maxHeight = void 0;
      if (Number.isInteger(topOffset)) {
        maxHeight = 'calc(100vh - ' + topOffset + 'px)';
      } else {
        maxHeight = 'calc(100vh - ' + topOffset + ')';
      }

      var buttonAppearance = void 0;
      if (type === 'default') {
        buttonAppearance = 'green';
      } else if (type === 'danger') {
        buttonAppearance = 'red';
      }

      return React.createElement(
        Overlay,
        {
          isShown: isShown,
          onExited: onCloseComplete,
          onEntered: onOpenComplete
        },
        function (_ref2) {
          var state = _ref2.state,
              close = _ref2.close;
          return React.createElement(
            Pane,
            {
              boxSizing: 'border-box',
              display: 'flex',
              justifyContent: 'center',
              paddingTop: topOffset,
              maxHeight: maxHeight
            },
            React.createElement(
              Pane,
              _extends({
                role: 'dialog',
                backgroundColor: 'white',
                elevation: 4,
                borderRadius: 8,
                width: width,
                display: 'flex',
                flexDirection: 'column',
                css: animationStyles,
                'data-state': state
              }, containerProps),
              hasHeader && React.createElement(
                Pane,
                {
                  padding: 16,
                  flexShrink: 0,
                  borderBottom: 'extraMuted',
                  display: 'flex',
                  alignItems: 'center'
                },
                React.createElement(
                  Heading,
                  { is: 'h4', size: 600, flex: '1' },
                  title
                ),
                React.createElement(IconButton, { appearance: 'ghost', icon: 'close', onClick: close })
              ),
              React.createElement(
                Pane,
                {
                  'data-state': state,
                  display: 'flex',
                  overflowY: 'auto',
                  padding: 16,
                  flexDirection: 'column',
                  minHeight: minHeightContent
                },
                React.createElement(
                  Pane,
                  null,
                  _this2.renderChildren(close)
                )
              ),
              hasFooter && React.createElement(
                Pane,
                {
                  borderTop: 'extraMuted',
                  flexShrink: 0,
                  padding: 16,
                  display: 'flex',
                  justifyContent: 'flex-end'
                },
                hasCancel && React.createElement(
                  Button,
                  { tabIndex: 0, onClick: close },
                  cancelLabel
                ),
                React.createElement(
                  Button,
                  {
                    tabIndex: 0,
                    marginLeft: 8,
                    appearance: buttonAppearance,
                    isLoading: isConfirmLoading,
                    disabled: isConfirmDisabled,
                    onClick: function onClick() {
                      return onConfirm(close);
                    }
                  },
                  confirmLabel
                )
              )
            )
          );
        }
      );
    }
  }]);

  return Dialog;
}(React.Component);

Dialog.propTypes = {
  /**
   * Children can be a string, node or a function accepting `({ close })`.
   * When passing a string, <Paragraph /> is used to wrap the string.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * When true, the dialog is shown.
   */
  isShown: PropTypes.bool,

  /**
   * Title of the Dialog. Titles should use Title Case.
   */
  title: PropTypes.node,

  /**
   * When true, the header with the title and close icon button is shown.
   */
  hasHeader: PropTypes.bool,

  /**
   * When true, the footer with the cancel and confirm button is shown.
   */
  hasFooter: PropTypes.bool,

  /**
   * When true, the cancel button is shown.
   */
  hasCancel: PropTypes.bool,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: PropTypes.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: PropTypes.func,

  /**
   * Function that will be called when the confirm button is clicked.
   * This does not close the Dialog. A close function will be passed
   * as a paramater you can use to close the dialog.
   *
   * `onConfirm={(close) => close()}`
   */
  onConfirm: PropTypes.func,

  /**
   * Label of the confirm button.
   */
  confirmLabel: PropTypes.string,

  /**
   * The type of the message.
   */
  type: PropTypes.oneOf(['default', 'danger']),

  /**
   * When true, the confirm button is set to loading.
   */
  isConfirmLoading: PropTypes.bool,

  /**
   * When true, the confirm button is set to disabled.
   */
  isConfirmDisabled: PropTypes.bool,

  /**
   * Function that will be called when the cancel button is clicked.
   * This closes the Dialog by default.
   *
   * `onCancel={(close) => close()}`
   */
  onCancel: PropTypes.func,

  /**
   * Label of the cancel button.
   */
  cancelLabel: PropTypes.string,

  /**
   * Width of the Dialog.
   */
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * The space above the dialog.
   * This offset is also used at the bottom when there is not enough space
   * available on screen â€” and the dialog scrolls internally.
   */
  topOffset: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * The min height of the body content.
   * Makes it less weird when only showing little content.
   */
  minHeightContent: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Props that are passed to the dialog container.
   */
  containerProps: PropTypes.object
};
Dialog.defaultProps = {
  isShown: false,
  hasHeader: true,
  hasFooter: true,
  hasCancel: true,
  type: 'default',
  width: 560,
  topOffset: '12vh',
  minHeightContent: 80,
  confirmLabel: 'Confirm',
  isConfirmLoading: false,
  isConfirmDisabled: false,
  cancelLabel: 'Cancel',
  onCancel: function onCancel(close) {
    return close();
  },
  onConfirm: function onConfirm(close) {
    return close();
  }
};


export default Dialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsb2cvc3JjL0RpYWxvZy5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlByb3BUeXBlcyIsImNzcyIsIlBhbmUiLCJQYXJhZ3JhcGgiLCJIZWFkaW5nIiwiT3ZlcmxheSIsIkJ1dHRvbiIsIkljb25CdXR0b24iLCJhbmltYXRpb25FYXNpbmciLCJkZWNlbGVyYXRpb24iLCJhY2NlbGVyYXRpb24iLCJBTklNQVRJT05fRFVSQVRJT04iLCJvcGVuQW5pbWF0aW9uIiwia2V5ZnJhbWVzIiwiZnJvbSIsInRyYW5zZm9ybSIsIm9wYWNpdHkiLCJ0byIsImNsb3NlQW5pbWF0aW9uIiwiYW5pbWF0aW9uU3R5bGVzIiwiYW5pbWF0aW9uIiwiRGlhbG9nIiwicmVuZGVyQ2hpbGRyZW4iLCJjaGlsZHJlbiIsInByb3BzIiwiY2xvc2UiLCJ0aXRsZSIsIndpZHRoIiwidHlwZSIsImlzU2hvd24iLCJ0b3BPZmZzZXQiLCJoYXNIZWFkZXIiLCJoYXNGb290ZXIiLCJoYXNDYW5jZWwiLCJvbkNsb3NlQ29tcGxldGUiLCJvbk9wZW5Db21wbGV0ZSIsIm9uQ29uZmlybSIsImNvbmZpcm1MYWJlbCIsImlzQ29uZmlybUxvYWRpbmciLCJpc0NvbmZpcm1EaXNhYmxlZCIsImNhbmNlbExhYmVsIiwiY29udGFpbmVyUHJvcHMiLCJtaW5IZWlnaHRDb250ZW50IiwibWF4SGVpZ2h0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYnV0dG9uQXBwZWFyYW5jZSIsInN0YXRlIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwib25lT2ZUeXBlIiwibm9kZSIsImZ1bmMiLCJpc1JlcXVpcmVkIiwiYm9vbCIsInN0cmluZyIsIm9uZU9mIiwib25DYW5jZWwiLCJudW1iZXIiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLE1BQWtCLE9BQWxCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVND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ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IGNzcyB9IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBQYXJhZ3JhcGgsIEhlYWRpbmcgfSBmcm9tICcuLi8uLi90eXBvZ3JhcGh5J1xuaW1wb3J0IHsgT3ZlcmxheSB9IGZyb20gJy4uLy4uL292ZXJsYXknXG5pbXBvcnQgeyBCdXR0b24sIEljb25CdXR0b24gfSBmcm9tICcuLi8uLi9idXR0b25zJ1xuXG5jb25zdCBhbmltYXRpb25FYXNpbmcgPSB7XG4gIGRlY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjAsIDAuMCwgMC4yLCAxKWAsXG4gIGFjY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSlgXG59XG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDIwMFxuXG5jb25zdCBvcGVuQW5pbWF0aW9uID0gY3NzLmtleWZyYW1lcygnb3BlbkFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDAuOCknLFxuICAgIG9wYWNpdHk6IDBcbiAgfSxcbiAgdG86IHtcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgb3BhY2l0eTogMVxuICB9XG59KVxuXG5jb25zdCBjbG9zZUFuaW1hdGlvbiA9IGNzcy5rZXlmcmFtZXMoJ2Nsb3NlQW5pbWF0aW9uJywge1xuICBmcm9tOiB7XG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgIG9wYWNpdHk6IDFcbiAgfSxcbiAgdG86IHtcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjgpJyxcbiAgICBvcGFjaXR5OiAwXG4gIH1cbn0pXG5cbmNvbnN0IGFuaW1hdGlvblN0eWxlcyA9IHtcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdLCAmW2RhdGEtc3RhdGU9XCJlbnRlcmVkXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7b3BlbkFuaW1hdGlvbn0gJHtBTklNQVRJT05fRFVSQVRJT059bXMgJHtcbiAgICAgIGFuaW1hdGlvbkVhc2luZy5kZWNlbGVyYXRpb25cbiAgICB9IGJvdGhgXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7Y2xvc2VBbmltYXRpb259ICR7QU5JTUFUSU9OX0RVUkFUSU9OfW1zICR7XG4gICAgICBhbmltYXRpb25FYXNpbmcuYWNjZWxlcmF0aW9uXG4gICAgfSBib3RoYFxuICB9XG59XG5cbmNsYXNzIERpYWxvZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gY2FuIGJlIGEgc3RyaW5nLCBub2RlIG9yIGEgZnVuY3Rpb24gYWNjZXB0aW5nIGAoeyBjbG9zZSB9KWAuXG4gICAgICogV2hlbiBwYXNzaW5nIGEgc3RyaW5nLCA8UGFyYWdyYXBoIC8+IGlzIHVzZWQgdG8gd3JhcCB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgZGlhbG9nIGlzIHNob3duLlxuICAgICAqL1xuICAgIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogVGl0bGUgb2YgdGhlIERpYWxvZy4gVGl0bGVzIHNob3VsZCB1c2UgVGl0bGUgQ2FzZS5cbiAgICAgKi9cbiAgICB0aXRsZTogUHJvcFR5cGVzLm5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBoZWFkZXIgd2l0aCB0aGUgdGl0bGUgYW5kIGNsb3NlIGljb24gYnV0dG9uIGlzIHNob3duLlxuICAgICAqL1xuICAgIGhhc0hlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBmb290ZXIgd2l0aCB0aGUgY2FuY2VsIGFuZCBjb25maXJtIGJ1dHRvbiBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBoYXNGb290ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgY2FuY2VsIGJ1dHRvbiBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBoYXNDYW5jZWw6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBleGl0IHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25DbG9zZUNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbmZpcm0gYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAgICogVGhpcyBkb2VzIG5vdCBjbG9zZSB0aGUgRGlhbG9nLiBBIGNsb3NlIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkXG4gICAgICogYXMgYSBwYXJhbWF0ZXIgeW91IGNhbiB1c2UgdG8gY2xvc2UgdGhlIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIGBvbkNvbmZpcm09eyhjbG9zZSkgPT4gY2xvc2UoKX1gXG4gICAgICovXG4gICAgb25Db25maXJtOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIExhYmVsIG9mIHRoZSBjb25maXJtIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBjb25maXJtTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydkZWZhdWx0JywgJ2RhbmdlciddKSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGNvbmZpcm0gYnV0dG9uIGlzIHNldCB0byBsb2FkaW5nLlxuICAgICAqL1xuICAgIGlzQ29uZmlybUxvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgY29uZmlybSBidXR0b24gaXMgc2V0IHRvIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGlzQ29uZmlybURpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAqIFRoaXMgY2xvc2VzIHRoZSBEaWFsb2cgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIGBvbkNhbmNlbD17KGNsb3NlKSA9PiBjbG9zZSgpfWBcbiAgICAgKi9cbiAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBvZiB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBjYW5jZWxMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBEaWFsb2cuXG4gICAgICovXG4gICAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzcGFjZSBhYm92ZSB0aGUgZGlhbG9nLlxuICAgICAqIFRoaXMgb2Zmc2V0IGlzIGFsc28gdXNlZCBhdCB0aGUgYm90dG9tIHdoZW4gdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZVxuICAgICAqIGF2YWlsYWJsZSBvbiBzY3JlZW4g4oCUIGFuZCB0aGUgZGlhbG9nIHNjcm9sbHMgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICB0b3BPZmZzZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW4gaGVpZ2h0IG9mIHRoZSBib2R5IGNvbnRlbnQuXG4gICAgICogTWFrZXMgaXQgbGVzcyB3ZWlyZCB3aGVuIG9ubHkgc2hvd2luZyBsaXR0bGUgY29udGVudC5cbiAgICAgKi9cbiAgICBtaW5IZWlnaHRDb250ZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgICAvKipcbiAgICAgKiBQcm9wcyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGRpYWxvZyBjb250YWluZXIuXG4gICAgICovXG4gICAgY29udGFpbmVyUHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgaXNTaG93bjogZmFsc2UsXG4gICAgaGFzSGVhZGVyOiB0cnVlLFxuICAgIGhhc0Zvb3RlcjogdHJ1ZSxcbiAgICBoYXNDYW5jZWw6IHRydWUsXG4gICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgIHdpZHRoOiA1NjAsXG4gICAgdG9wT2Zmc2V0OiAnMTJ2aCcsXG4gICAgbWluSGVpZ2h0Q29udGVudDogODAsXG4gICAgY29uZmlybUxhYmVsOiAnQ29uZmlybScsXG4gICAgaXNDb25maXJtTG9hZGluZzogZmFsc2UsXG4gICAgaXNDb25maXJtRGlzYWJsZWQ6IGZhbHNlLFxuICAgIGNhbmNlbExhYmVsOiAnQ2FuY2VsJyxcbiAgICBvbkNhbmNlbDogY2xvc2UgPT4gY2xvc2UoKSxcbiAgICBvbkNvbmZpcm06IGNsb3NlID0+IGNsb3NlKClcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuID0gY2xvc2UgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHNcblxuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbih7IGNsb3NlIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gPFBhcmFncmFwaD57Y2hpbGRyZW59PC9QYXJhZ3JhcGg+XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpdGxlLFxuICAgICAgd2lkdGgsXG4gICAgICB0eXBlLFxuICAgICAgaXNTaG93bixcbiAgICAgIHRvcE9mZnNldCxcbiAgICAgIGhhc0hlYWRlcixcbiAgICAgIGhhc0Zvb3RlcixcbiAgICAgIGhhc0NhbmNlbCxcbiAgICAgIG9uQ2xvc2VDb21wbGV0ZSxcbiAgICAgIG9uT3BlbkNvbXBsZXRlLFxuICAgICAgb25Db25maXJtLFxuICAgICAgY29uZmlybUxhYmVsLFxuICAgICAgaXNDb25maXJtTG9hZGluZyxcbiAgICAgIGlzQ29uZmlybURpc2FibGVkLFxuICAgICAgY2FuY2VsTGFiZWwsXG4gICAgICBjb250YWluZXJQcm9wcyxcbiAgICAgIG1pbkhlaWdodENvbnRlbnRcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IG1heEhlaWdodFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRvcE9mZnNldCkpIHtcbiAgICAgIG1heEhlaWdodCA9IGBjYWxjKDEwMHZoIC0gJHt0b3BPZmZzZXR9cHgpYFxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhIZWlnaHQgPSBgY2FsYygxMDB2aCAtICR7dG9wT2Zmc2V0fSlgXG4gICAgfVxuXG4gICAgbGV0IGJ1dHRvbkFwcGVhcmFuY2VcbiAgICBpZiAodHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICBidXR0b25BcHBlYXJhbmNlID0gJ2dyZWVuJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RhbmdlcicpIHtcbiAgICAgIGJ1dHRvbkFwcGVhcmFuY2UgPSAncmVkJ1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8T3ZlcmxheVxuICAgICAgICBpc1Nob3duPXtpc1Nob3dufVxuICAgICAgICBvbkV4aXRlZD17b25DbG9zZUNvbXBsZXRlfVxuICAgICAgICBvbkVudGVyZWQ9e29uT3BlbkNvbXBsZXRlfVxuICAgICAgPlxuICAgICAgICB7KHsgc3RhdGUsIGNsb3NlIH0pID0+IChcbiAgICAgICAgICA8UGFuZVxuICAgICAgICAgICAgYm94U2l6aW5nPVwiYm9yZGVyLWJveFwiXG4gICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiXG4gICAgICAgICAgICBwYWRkaW5nVG9wPXt0b3BPZmZzZXR9XG4gICAgICAgICAgICBtYXhIZWlnaHQ9e21heEhlaWdodH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8UGFuZVxuICAgICAgICAgICAgICByb2xlPVwiZGlhbG9nXCJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBlbGV2YXRpb249ezR9XG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1cz17OH1cbiAgICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICAgICAgICBjc3M9e2FuaW1hdGlvblN0eWxlc31cbiAgICAgICAgICAgICAgZGF0YS1zdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgIHsuLi5jb250YWluZXJQcm9wc31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2hhc0hlYWRlciAmJiAoXG4gICAgICAgICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc9ezE2fVxuICAgICAgICAgICAgICAgICAgZmxleFNocmluaz17MH1cbiAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbT1cImV4dHJhTXV0ZWRcIlxuICAgICAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPEhlYWRpbmcgaXM9XCJoNFwiIHNpemU9ezYwMH0gZmxleD1cIjFcIj5cbiAgICAgICAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gYXBwZWFyYW5jZT1cImdob3N0XCIgaWNvbj1cImNsb3NlXCIgb25DbGljaz17Y2xvc2V9IC8+XG4gICAgICAgICAgICAgICAgPC9QYW5lPlxuICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgICAgZGF0YS1zdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICAgIG92ZXJmbG93WT1cImF1dG9cIlxuICAgICAgICAgICAgICAgIHBhZGRpbmc9ezE2fVxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgIG1pbkhlaWdodD17bWluSGVpZ2h0Q29udGVudH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxQYW5lPnt0aGlzLnJlbmRlckNoaWxkcmVuKGNsb3NlKX08L1BhbmU+XG4gICAgICAgICAgICAgIDwvUGFuZT5cblxuICAgICAgICAgICAgICB7aGFzRm9vdGVyICYmIChcbiAgICAgICAgICAgICAgICA8UGFuZVxuICAgICAgICAgICAgICAgICAgYm9yZGVyVG9wPVwiZXh0cmFNdXRlZFwiXG4gICAgICAgICAgICAgICAgICBmbGV4U2hyaW5rPXswfVxuICAgICAgICAgICAgICAgICAgcGFkZGluZz17MTZ9XG4gICAgICAgICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudD1cImZsZXgtZW5kXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7LyogQ2FuY2VsIHNob3VsZCBiZSBmaXJzdCB0byBtYWtlIHN1cmUgZm9jdXMgZ2V0cyBvbiBpdCBmaXJzdC4gKi99XG4gICAgICAgICAgICAgICAgICB7aGFzQ2FuY2VsICYmIChcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB0YWJJbmRleD17MH0gb25DbGljaz17Y2xvc2V9PlxuICAgICAgICAgICAgICAgICAgICAgIHtjYW5jZWxMYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0PXs4fVxuICAgICAgICAgICAgICAgICAgICBhcHBlYXJhbmNlPXtidXR0b25BcHBlYXJhbmNlfVxuICAgICAgICAgICAgICAgICAgICBpc0xvYWRpbmc9e2lzQ29uZmlybUxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc0NvbmZpcm1EaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25Db25maXJtKGNsb3NlKX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2NvbmZpcm1MYWJlbH1cbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICl9XG4gICAgICA8L092ZXJsYXk+XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZ1xuIl19