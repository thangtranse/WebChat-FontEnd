'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uiBox = require('ui-box');

var _layers = require('../../layers');

var _typography = require('../../typography');

var _overlay = require('../../overlay');

var _buttons = require('../../buttons');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)'
};

var ANIMATION_DURATION = 200;

var openAnimation = _uiBox.css.keyframes('openAnimation', {
  from: {
    transform: 'scale(0.8)',
    opacity: 0
  },
  to: {
    transform: 'scale(1)',
    opacity: 1
  }
});

var closeAnimation = _uiBox.css.keyframes('closeAnimation', {
  from: {
    transform: 'scale(1)',
    opacity: 1
  },
  to: {
    transform: 'scale(0.8)',
    opacity: 0
  }
});

var animationStyles = {
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: openAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.deceleration + ' both'
  },
  '&[data-state="exiting"]': {
    animation: closeAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.acceleration + ' both'
  }
};

var Dialog = function (_React$Component) {
  _inherits(Dialog, _React$Component);

  function Dialog() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Dialog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Dialog.__proto__ || Object.getPrototypeOf(Dialog)).call.apply(_ref, [this].concat(args))), _this), _this.renderChildren = function (close) {
      var children = _this.props.children;


      if (typeof children === 'function') {
        return children({ close: close });
      } else if (typeof children === 'string') {
        return _react2.default.createElement(
          _typography.Paragraph,
          null,
          children
        );
      }
      return children;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Dialog, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          title = _props.title,
          width = _props.width,
          type = _props.type,
          isShown = _props.isShown,
          topOffset = _props.topOffset,
          hasHeader = _props.hasHeader,
          hasFooter = _props.hasFooter,
          hasCancel = _props.hasCancel,
          onCloseComplete = _props.onCloseComplete,
          onOpenComplete = _props.onOpenComplete,
          onConfirm = _props.onConfirm,
          confirmLabel = _props.confirmLabel,
          isConfirmLoading = _props.isConfirmLoading,
          isConfirmDisabled = _props.isConfirmDisabled,
          cancelLabel = _props.cancelLabel,
          containerProps = _props.containerProps,
          minHeightContent = _props.minHeightContent;


      var maxHeight = void 0;
      if (Number.isInteger(topOffset)) {
        maxHeight = 'calc(100vh - ' + topOffset + 'px)';
      } else {
        maxHeight = 'calc(100vh - ' + topOffset + ')';
      }

      var buttonAppearance = void 0;
      if (type === 'default') {
        buttonAppearance = 'green';
      } else if (type === 'danger') {
        buttonAppearance = 'red';
      }

      return _react2.default.createElement(
        _overlay.Overlay,
        {
          isShown: isShown,
          onExited: onCloseComplete,
          onEntered: onOpenComplete
        },
        function (_ref2) {
          var state = _ref2.state,
              close = _ref2.close;
          return _react2.default.createElement(
            _layers.Pane,
            {
              boxSizing: 'border-box',
              display: 'flex',
              justifyContent: 'center',
              paddingTop: topOffset,
              maxHeight: maxHeight
            },
            _react2.default.createElement(
              _layers.Pane,
              _extends({
                role: 'dialog',
                backgroundColor: 'white',
                elevation: 4,
                borderRadius: 8,
                width: width,
                display: 'flex',
                flexDirection: 'column',
                css: animationStyles,
                'data-state': state
              }, containerProps),
              hasHeader && _react2.default.createElement(
                _layers.Pane,
                {
                  padding: 16,
                  flexShrink: 0,
                  borderBottom: 'extraMuted',
                  display: 'flex',
                  alignItems: 'center'
                },
                _react2.default.createElement(
                  _typography.Heading,
                  { is: 'h4', size: 600, flex: '1' },
                  title
                ),
                _react2.default.createElement(_buttons.IconButton, { appearance: 'ghost', icon: 'close', onClick: close })
              ),
              _react2.default.createElement(
                _layers.Pane,
                {
                  'data-state': state,
                  display: 'flex',
                  overflowY: 'auto',
                  padding: 16,
                  flexDirection: 'column',
                  minHeight: minHeightContent
                },
                _react2.default.createElement(
                  _layers.Pane,
                  null,
                  _this2.renderChildren(close)
                )
              ),
              hasFooter && _react2.default.createElement(
                _layers.Pane,
                {
                  borderTop: 'extraMuted',
                  flexShrink: 0,
                  padding: 16,
                  display: 'flex',
                  justifyContent: 'flex-end'
                },
                hasCancel && _react2.default.createElement(
                  _buttons.Button,
                  { tabIndex: 0, onClick: close },
                  cancelLabel
                ),
                _react2.default.createElement(
                  _buttons.Button,
                  {
                    tabIndex: 0,
                    marginLeft: 8,
                    appearance: buttonAppearance,
                    isLoading: isConfirmLoading,
                    disabled: isConfirmDisabled,
                    onClick: function onClick() {
                      return onConfirm(close);
                    }
                  },
                  confirmLabel
                )
              )
            )
          );
        }
      );
    }
  }]);

  return Dialog;
}(_react2.default.Component);

Dialog.propTypes = {
  /**
   * Children can be a string, node or a function accepting `({ close })`.
   * When passing a string, <Paragraph /> is used to wrap the string.
   */
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]).isRequired,

  /**
   * When true, the dialog is shown.
   */
  isShown: _propTypes2.default.bool,

  /**
   * Title of the Dialog. Titles should use Title Case.
   */
  title: _propTypes2.default.node,

  /**
   * When true, the header with the title and close icon button is shown.
   */
  hasHeader: _propTypes2.default.bool,

  /**
   * When true, the footer with the cancel and confirm button is shown.
   */
  hasFooter: _propTypes2.default.bool,

  /**
   * When true, the cancel button is shown.
   */
  hasCancel: _propTypes2.default.bool,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: _propTypes2.default.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: _propTypes2.default.func,

  /**
   * Function that will be called when the confirm button is clicked.
   * This does not close the Dialog. A close function will be passed
   * as a paramater you can use to close the dialog.
   *
   * `onConfirm={(close) => close()}`
   */
  onConfirm: _propTypes2.default.func,

  /**
   * Label of the confirm button.
   */
  confirmLabel: _propTypes2.default.string,

  /**
   * The type of the message.
   */
  type: _propTypes2.default.oneOf(['default', 'danger']),

  /**
   * When true, the confirm button is set to loading.
   */
  isConfirmLoading: _propTypes2.default.bool,

  /**
   * When true, the confirm button is set to disabled.
   */
  isConfirmDisabled: _propTypes2.default.bool,

  /**
   * Function that will be called when the cancel button is clicked.
   * This closes the Dialog by default.
   *
   * `onCancel={(close) => close()}`
   */
  onCancel: _propTypes2.default.func,

  /**
   * Label of the cancel button.
   */
  cancelLabel: _propTypes2.default.string,

  /**
   * Width of the Dialog.
   */
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),

  /**
   * The space above the dialog.
   * This offset is also used at the bottom when there is not enough space
   * available on screen â€” and the dialog scrolls internally.
   */
  topOffset: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),

  /**
   * The min height of the body content.
   * Makes it less weird when only showing little content.
   */
  minHeightContent: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),

  /**
   * Props that are passed to the dialog container.
   */
  containerProps: _propTypes2.default.object
};
Dialog.defaultProps = {
  isShown: false,
  hasHeader: true,
  hasFooter: true,
  hasCancel: true,
  type: 'default',
  width: 560,
  topOffset: '12vh',
  minHeightContent: 80,
  confirmLabel: 'Confirm',
  isConfirmLoading: false,
  isConfirmDisabled: false,
  cancelLabel: 'Cancel',
  onCancel: function onCancel(close) {
    return close();
  },
  onConfirm: function onConfirm(close) {
    return close();
  }
};
exports.default = Dialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsb2cvc3JjL0RpYWxvZy5qcyJdLCJuYW1lcyI6WyJhbmltYXRpb25FYXNpbmciLCJkZWNlbGVyYXRpb24iLCJhY2NlbGVyYXRpb24iLCJBTklNQVRJT05fRFVSQVRJT04iLCJvcGVuQW5pbWF0aW9uIiwia2V5ZnJhbWVzIiwiZnJvbSIsInRyYW5zZm9ybSIsIm9wYWNpdHkiLCJ0byIsImNsb3NlQW5pbWF0aW9uIiwiYW5pbWF0aW9uU3R5bGVzIiwiYW5pbWF0aW9uIiwiRGlhbG9nIiwicmVuZGVyQ2hpbGRyZW4iLCJjaGlsZHJlbiIsInByb3BzIiwiY2xvc2UiLCJ0aXRsZSIsIndpZHRoIiwidHlwZSIsImlzU2hvd24iLCJ0b3BPZmZzZXQiLCJoYXNIZWFkZXIiLCJoYXNGb290ZXIiLCJoYXNDYW5jZWwiLCJvbkNsb3NlQ29tcGxldGUiLCJvbk9wZW5Db21wbGV0ZSIsIm9uQ29uZmlybSIsImNvbmZpcm1MYWJlbCIsImlzQ29uZmlybUxvYWRpbmciLCJpc0NvbmZpcm1EaXNhYmxlZCIsImNhbmNlbExhYmVsIiwiY29udGFpbmVyUHJvcHMiLCJtaW5IZWlnaHRDb250ZW50IiwibWF4SGVpZ2h0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYnV0dG9uQXBwZWFyYW5jZSIsInN0YXRlIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwib25lT2ZUeXBlIiwibm9kZSIsImZ1bmMiLCJpc1JlcXVpcmVkIiwiYm9vbCIsInN0cmluZyIsIm9uZU9mIiwib25DYW5jZWwiLCJudW1iZXIiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxrQkFBa0I7QUFDdEJDLGdEQURzQjtBQUV0QkM7QUFGc0IsQ0FBeEI7O0FBS0EsSUFBTUMscUJBQXFCLEdBQTNCOztBQUVBLElBQU1DLGdCQUFnQixXQUFJ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b0JBQVVHLE1BQTdCLENBQXBCLENBOUZNOztBQWdHakI7Ozs7QUFJQWhCLG9CQUFrQixvQkFBVVEsU0FBVixDQUFvQixDQUFDLG9CQUFVSyxNQUFYLEVBQW1CLG9CQUFVRyxNQUE3QixDQUFwQixDQXBHRDs7QUFzR2pCOzs7QUFHQWpCLGtCQUFnQixvQkFBVWtCO0FBekdULEM7QUFEZnRDLE0sQ0E2R0d1QyxZLEdBQWU7QUFDcEIvQixXQUFTLEtBRFc7QUFFcEJFLGFBQVcsSUFGUztBQUdwQkMsYUFBVyxJQUhTO0FBSXBCQyxhQUFXLElBSlM7QUFLcEJMLFFBQU0sU0FMYztBQU1wQkQsU0FBTyxHQU5hO0FBT3BCRyxhQUFXLE1BUFM7QUFRcEJZLG9CQUFrQixFQVJFO0FBU3BCTCxnQkFBYyxTQVRNO0FBVXBCQyxvQkFBa0IsS0FWRTtBQVdwQkMscUJBQW1CLEtBWEM7QUFZcEJDLGVBQWEsUUFaTztBQWFwQmlCLFlBQVU7QUFBQSxXQUFTaEMsT0FBVDtBQUFBLEdBYlU7QUFjcEJXLGFBQVc7QUFBQSxXQUFTWCxPQUFUO0FBQUE7QUFkUyxDO2tCQXNKVEosTSIsImZpbGUiOiJEaWFsb2cuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBjc3MgfSBmcm9tICd1aS1ib3gnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IHsgUGFyYWdyYXBoLCBIZWFkaW5nIH0gZnJvbSAnLi4vLi4vdHlwb2dyYXBoeSdcbmltcG9ydCB7IE92ZXJsYXkgfSBmcm9tICcuLi8uLi9vdmVybGF5J1xuaW1wb3J0IHsgQnV0dG9uLCBJY29uQnV0dG9uIH0gZnJvbSAnLi4vLi4vYnV0dG9ucydcblxuY29uc3QgYW5pbWF0aW9uRWFzaW5nID0ge1xuICBkZWNlbGVyYXRpb246IGBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSlgLFxuICBhY2NlbGVyYXRpb246IGBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpYFxufVxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSAyMDBcblxuY29uc3Qgb3BlbkFuaW1hdGlvbiA9IGNzcy5rZXlmcmFtZXMoJ29wZW5BbmltYXRpb24nLCB7XG4gIGZyb206IHtcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjgpJyxcbiAgICBvcGFjaXR5OiAwXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgIG9wYWNpdHk6IDFcbiAgfVxufSlcblxuY29uc3QgY2xvc2VBbmltYXRpb24gPSBjc3Mua2V5ZnJhbWVzKCdjbG9zZUFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICBvcGFjaXR5OiAxXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXG4gICAgb3BhY2l0eTogMFxuICB9XG59KVxuXG5jb25zdCBhbmltYXRpb25TdHlsZXMgPSB7XG4gICcmW2RhdGEtc3RhdGU9XCJlbnRlcmluZ1wiXSwgJltkYXRhLXN0YXRlPVwiZW50ZXJlZFwiXSc6IHtcbiAgICBhbmltYXRpb246IGAke29wZW5BbmltYXRpb259ICR7QU5JTUFUSU9OX0RVUkFUSU9OfW1zICR7XG4gICAgICBhbmltYXRpb25FYXNpbmcuZGVjZWxlcmF0aW9uXG4gICAgfSBib3RoYFxuICB9LFxuICAnJltkYXRhLXN0YXRlPVwiZXhpdGluZ1wiXSc6IHtcbiAgICBhbmltYXRpb246IGAke2Nsb3NlQW5pbWF0aW9ufSAke0FOSU1BVElPTl9EVVJBVElPTn1tcyAke1xuICAgICAgYW5pbWF0aW9uRWFzaW5nLmFjY2VsZXJhdGlvblxuICAgIH0gYm90aGBcbiAgfVxufVxuXG5jbGFzcyBEaWFsb2cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENoaWxkcmVuIGNhbiBiZSBhIHN0cmluZywgbm9kZSBvciBhIGZ1bmN0aW9uIGFjY2VwdGluZyBgKHsgY2xvc2UgfSlgLlxuICAgICAqIFdoZW4gcGFzc2luZyBhIHN0cmluZywgPFBhcmFncmFwaCAvPiBpcyB1c2VkIHRvIHdyYXAgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGRpYWxvZyBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBpc1Nob3duOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRpdGxlIG9mIHRoZSBEaWFsb2cuIFRpdGxlcyBzaG91bGQgdXNlIFRpdGxlIENhc2UuXG4gICAgICovXG4gICAgdGl0bGU6IFByb3BUeXBlcy5ub2RlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgaGVhZGVyIHdpdGggdGhlIHRpdGxlIGFuZCBjbG9zZSBpY29uIGJ1dHRvbiBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBoYXNIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgZm9vdGVyIHdpdGggdGhlIGNhbmNlbCBhbmQgY29uZmlybSBidXR0b24gaXMgc2hvd24uXG4gICAgICovXG4gICAgaGFzRm9vdGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGNhbmNlbCBidXR0b24gaXMgc2hvd24uXG4gICAgICovXG4gICAgaGFzQ2FuY2VsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXhpdCB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIG9uQ2xvc2VDb21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGVudGVyIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25PcGVuQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb25maXJtIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAqIFRoaXMgZG9lcyBub3QgY2xvc2UgdGhlIERpYWxvZy4gQSBjbG9zZSBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZFxuICAgICAqIGFzIGEgcGFyYW1hdGVyIHlvdSBjYW4gdXNlIHRvIGNsb3NlIHRoZSBkaWFsb2cuXG4gICAgICpcbiAgICAgKiBgb25Db25maXJtPXsoY2xvc2UpID0+IGNsb3NlKCl9YFxuICAgICAqL1xuICAgIG9uQ29uZmlybTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBvZiB0aGUgY29uZmlybSBidXR0b24uXG4gICAgICovXG4gICAgY29uZmlybUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdkYW5nZXInXSksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBjb25maXJtIGJ1dHRvbiBpcyBzZXQgdG8gbG9hZGluZy5cbiAgICAgKi9cbiAgICBpc0NvbmZpcm1Mb2FkaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGNvbmZpcm0gYnV0dG9uIGlzIHNldCB0byBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBpc0NvbmZpcm1EaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNhbmNlbCBidXR0b24gaXMgY2xpY2tlZC5cbiAgICAgKiBUaGlzIGNsb3NlcyB0aGUgRGlhbG9nIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBgb25DYW5jZWw9eyhjbG9zZSkgPT4gY2xvc2UoKX1gXG4gICAgICovXG4gICAgb25DYW5jZWw6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgb2YgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICovXG4gICAgY2FuY2VsTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgRGlhbG9nLlxuICAgICAqL1xuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BhY2UgYWJvdmUgdGhlIGRpYWxvZy5cbiAgICAgKiBUaGlzIG9mZnNldCBpcyBhbHNvIHVzZWQgYXQgdGhlIGJvdHRvbSB3aGVuIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2VcbiAgICAgKiBhdmFpbGFibGUgb24gc2NyZWVuIOKAlCBhbmQgdGhlIGRpYWxvZyBzY3JvbGxzIGludGVybmFsbHkuXG4gICAgICovXG4gICAgdG9wT2Zmc2V0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluIGhlaWdodCBvZiB0aGUgYm9keSBjb250ZW50LlxuICAgICAqIE1ha2VzIGl0IGxlc3Mgd2VpcmQgd2hlbiBvbmx5IHNob3dpbmcgbGl0dGxlIGNvbnRlbnQuXG4gICAgICovXG4gICAgbWluSGVpZ2h0Q29udGVudDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuXG4gICAgLyoqXG4gICAgICogUHJvcHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBkaWFsb2cgY29udGFpbmVyLlxuICAgICAqL1xuICAgIGNvbnRhaW5lclByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGlzU2hvd246IGZhbHNlLFxuICAgIGhhc0hlYWRlcjogdHJ1ZSxcbiAgICBoYXNGb290ZXI6IHRydWUsXG4gICAgaGFzQ2FuY2VsOiB0cnVlLFxuICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICB3aWR0aDogNTYwLFxuICAgIHRvcE9mZnNldDogJzEydmgnLFxuICAgIG1pbkhlaWdodENvbnRlbnQ6IDgwLFxuICAgIGNvbmZpcm1MYWJlbDogJ0NvbmZpcm0nLFxuICAgIGlzQ29uZmlybUxvYWRpbmc6IGZhbHNlLFxuICAgIGlzQ29uZmlybURpc2FibGVkOiBmYWxzZSxcbiAgICBjYW5jZWxMYWJlbDogJ0NhbmNlbCcsXG4gICAgb25DYW5jZWw6IGNsb3NlID0+IGNsb3NlKCksXG4gICAgb25Db25maXJtOiBjbG9zZSA9PiBjbG9zZSgpXG4gIH1cblxuICByZW5kZXJDaGlsZHJlbiA9IGNsb3NlID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4oeyBjbG9zZSB9KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIDxQYXJhZ3JhcGg+e2NoaWxkcmVufTwvUGFyYWdyYXBoPlxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0aXRsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgdHlwZSxcbiAgICAgIGlzU2hvd24sXG4gICAgICB0b3BPZmZzZXQsXG4gICAgICBoYXNIZWFkZXIsXG4gICAgICBoYXNGb290ZXIsXG4gICAgICBoYXNDYW5jZWwsXG4gICAgICBvbkNsb3NlQ29tcGxldGUsXG4gICAgICBvbk9wZW5Db21wbGV0ZSxcbiAgICAgIG9uQ29uZmlybSxcbiAgICAgIGNvbmZpcm1MYWJlbCxcbiAgICAgIGlzQ29uZmlybUxvYWRpbmcsXG4gICAgICBpc0NvbmZpcm1EaXNhYmxlZCxcbiAgICAgIGNhbmNlbExhYmVsLFxuICAgICAgY29udGFpbmVyUHJvcHMsXG4gICAgICBtaW5IZWlnaHRDb250ZW50XG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBtYXhIZWlnaHRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih0b3BPZmZzZXQpKSB7XG4gICAgICBtYXhIZWlnaHQgPSBgY2FsYygxMDB2aCAtICR7dG9wT2Zmc2V0fXB4KWBcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4SGVpZ2h0ID0gYGNhbGMoMTAwdmggLSAke3RvcE9mZnNldH0pYFxuICAgIH1cblxuICAgIGxldCBidXR0b25BcHBlYXJhbmNlXG4gICAgaWYgKHR5cGUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgYnV0dG9uQXBwZWFyYW5jZSA9ICdncmVlbidcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkYW5nZXInKSB7XG4gICAgICBidXR0b25BcHBlYXJhbmNlID0gJ3JlZCdcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPE92ZXJsYXlcbiAgICAgICAgaXNTaG93bj17aXNTaG93bn1cbiAgICAgICAgb25FeGl0ZWQ9e29uQ2xvc2VDb21wbGV0ZX1cbiAgICAgICAgb25FbnRlcmVkPXtvbk9wZW5Db21wbGV0ZX1cbiAgICAgID5cbiAgICAgICAgeyh7IHN0YXRlLCBjbG9zZSB9KSA9PiAoXG4gICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgIGJveFNpemluZz1cImJvcmRlci1ib3hcIlxuICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICAgICAgcGFkZGluZ1RvcD17dG9wT2Zmc2V0fVxuICAgICAgICAgICAgbWF4SGVpZ2h0PXttYXhIZWlnaHR9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgZWxldmF0aW9uPXs0fVxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM9ezh9XG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgY3NzPXthbmltYXRpb25TdHlsZXN9XG4gICAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgICAgICB7Li4uY29udGFpbmVyUHJvcHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtoYXNIZWFkZXIgJiYgKFxuICAgICAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nPXsxNn1cbiAgICAgICAgICAgICAgICAgIGZsZXhTaHJpbms9ezB9XG4gICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b209XCJleHRyYU11dGVkXCJcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxIZWFkaW5nIGlzPVwiaDRcIiBzaXplPXs2MDB9IGZsZXg9XCIxXCI+XG4gICAgICAgICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIGFwcGVhcmFuY2U9XCJnaG9zdFwiIGljb249XCJjbG9zZVwiIG9uQ2xpY2s9e2Nsb3NlfSAvPlxuICAgICAgICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICA8UGFuZVxuICAgICAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k9XCJhdXRvXCJcbiAgICAgICAgICAgICAgICBwYWRkaW5nPXsxNn1cbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ9e21pbkhlaWdodENvbnRlbnR9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8UGFuZT57dGhpcy5yZW5kZXJDaGlsZHJlbihjbG9zZSl9PC9QYW5lPlxuICAgICAgICAgICAgICA8L1BhbmU+XG5cbiAgICAgICAgICAgICAge2hhc0Zvb3RlciAmJiAoXG4gICAgICAgICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgICAgICAgIGJvcmRlclRvcD1cImV4dHJhTXV0ZWRcIlxuICAgICAgICAgICAgICAgICAgZmxleFNocmluaz17MH1cbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc9ezE2fVxuICAgICAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJmbGV4LWVuZFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgey8qIENhbmNlbCBzaG91bGQgYmUgZmlyc3QgdG8gbWFrZSBzdXJlIGZvY3VzIGdldHMgb24gaXQgZmlyc3QuICovfVxuICAgICAgICAgICAgICAgICAge2hhc0NhbmNlbCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gdGFiSW5kZXg9ezB9IG9uQ2xpY2s9e2Nsb3NlfT5cbiAgICAgICAgICAgICAgICAgICAgICB7Y2FuY2VsTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdD17OH1cbiAgICAgICAgICAgICAgICAgICAgYXBwZWFyYW5jZT17YnV0dG9uQXBwZWFyYW5jZX1cbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkaW5nPXtpc0NvbmZpcm1Mb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNDb25maXJtRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uQ29uZmlybShjbG9zZSl9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtjb25maXJtTGFiZWx9XG4gICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICAgPC9QYW5lPlxuICAgICAgICApfVxuICAgICAgPC9PdmVybGF5PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dcbiJdfQ==